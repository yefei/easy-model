#!/usr/bin/env node

import fs from 'node:fs/promises';
import path from 'node:path';
import mysql from 'mysql2';
import { Query } from 'mysql-easy-query';

async function getConfig() {
  const configFile = path.join(process.cwd(), process.argv[3]);
  const config = configFile.endsWith('.json') ? JSON.parse(await fs.readFile(configFile)) : (await import('file://' + configFile)).default;
  const modelsOptionsDir = path.resolve(process.cwd(), config.optionsDir || 'models_options');
  const tsFilename = config.typingFile || 'models.d.ts';
  const tsFile = path.resolve(process.cwd(), tsFilename);
  const modelsFilename = config.modelsFile || 'models.js';
  const modelsFile = path.resolve(process.cwd(), modelsFilename);
  // let tsRelative = path.relative(modelsFile, tsFile).replace(/\\/g, '/').substring(3);
  // if (!tsRelative.startsWith('../')) tsRelative = `./${tsRelative}`;
  // tsRelative = tsRelative.slice(0, -5); // remove .d.ts
  return {
    ...config,
    modelsOptionsDir,
    tsFile,
    modelsFile,
  };
}

function getQuery(config) {
  const conn = mysql.createConnection({
    host: config.host || 'localhost',
    port: config.port || 3306,
    user: config.user || 'root',
    password: config.password,
    database: config.database,
  });
  return new Query(conn);
}

/**
 * @param {string} type
 */
function getColumnType(type) {
  if (type.search(/timestamp|datetime/i) != -1) return 'Date';
  if (type.search(/int|float/i) != -1) return 'number';
  return 'string';
}

/**
 * @param {string} name
 */
function nameCase(name) {
  return name.split('_').map(c => c[0].toUpperCase() + c.substring(1)).join('');
}

/**
 * @param {string} filename
 */
function checkFileDir(filename) {
  const dir = path.dirname(filename);
  return fs.mkdir(dir, { recursive: true });
}

async function main() {
  console.log('get tables...');
  const config = await getConfig();
  const query = getQuery(config);
  const tables = await query.query('SHOW TABLES');
  const remark = [
    '// zenorm auto generate',
    '// This file is automatically generated',
    '// Please do not modify',
    `// date: ${new Date().toLocaleString()}`,
    `// user: ${process.env.USER || process.env.USERNAME || 'unknown'}@${process.env.COMPUTERNAME || 'unknown'}`,
    `// database: ${config.database}`,
  ];
  const out = [
    ...remark,
    '',
    `import { Instance, Model, Query } from 'zenorm';`,
    '',
  ];
  const modelJs = [
    ...remark,
    `import fs from 'node:fs/promises';`,
    `import { Model } from 'zenorm';`,
    '',
    'const _modelMap = {};',
    '',
  ];
  const optionsJs = [];
  const queriesTs = [];
  const queriesJs = [];
  for (const t of tables) {
    const tableName = t[`Tables_in_${config.database}`];
    const className = nameCase(tableName);
    console.log('table:', tableName);
    const columns = await query.query('SHOW FULL COLUMNS FROM ??', [tableName]);
    let pk;
    out.push(`/**`);
    out.push(` * table: ${tableName}`);
    out.push(` */`);
    out.push(`export declare class ${className}Instance extends Instance {`);
    for (const c of columns) {
      if (!pk && c.Key === 'PRI') pk = c.Field;
      out.push(`  /**`);
      c.Comment && out.push(`   * ${c.Comment}`);
      out.push(`   * ${c.Type} ${c.Extra}`);
      out.push(`   */`);
      out.push(`  ${c.Field}: ${getColumnType(c.Type)};`);
    }
    out.push(`}`);
    out.push(``);
    out.push(`export declare class ${className}Model extends Model<${className}Instance> {}`);
    out.push(`export declare function ${className}Query(query: Query): ${className}Model;`);
    out.push(``);

    // options
    const optionFilename = path.join(config.modelsOptionsDir, `${tableName}.js`);
    let optionRelative = path.relative(config.modelsFile, optionFilename).replace(/\\/g, '/').substring(3);
    if (!optionRelative.startsWith('../')) optionRelative = `./${optionRelative}`;
    // optionRelative = optionRelative.slice(0, -3); // remove .js
    optionsJs.push(`await loadModelOption(${className}Option, '${optionRelative}');`);

    // js
    modelJs.push(`const ${className}Option = { name: '${tableName}', table: '${tableName}', pk: '${pk}', _modelMap };`);
    modelJs.push(`export function ${className}Query(query) { return new Model(${className}Option, query); }`);
    modelJs.push(`_modelMap['${tableName}'] = ${className}Query;`);
    modelJs.push(``);

    // queries
    const prop = `${className.charAt(0).toLowerCase()}${className.slice(1)}`;
    queriesTs.push(`  ${prop}: ${className}Model;`);
    queriesJs.push(`  get ${prop}() { return ${className}Query(this._query); }`);
  }

  // queries
  out.push(`export declare class Queries {`);
  out.push(`  constructor(query: Query);`);
  out.push(...queriesTs);
  out.push(`}`);
  out.push(``);
  out.push(`export declare function queries(query: Query): Queries;`);
  out.push(``);
  out.push(`export declare async function loadModelOptions(): voud;`);
  out.push(``);

  modelJs.push(`export class Queries {`);
  modelJs.push(`  constructor(query) { this._query = query; }`);
  modelJs.push(...queriesJs);
  modelJs.push(`}`);
  modelJs.push(``);

  modelJs.push(`export function queries(query) { return new Queries(query); }`);
  modelJs.push(``);

  modelJs.push(`/* options update */`);
  modelJs.push(`async function loadModelOption(option, file) {`);
  modelJs.push(`  const url = new URL(file, import.meta.url);`);
  modelJs.push(`  if (await fs.access(url).then(() => true, () => false)) {`);
  modelJs.push(`    const mod = await import(url);`);
  modelJs.push(`    Object.assign(option, mod.default);`);
  modelJs.push(`  }`);
  modelJs.push(`}`);
  modelJs.push(``);
  modelJs.push(...optionsJs);
  modelJs.push(``);

  console.log(`write types file: ${config.tsFile}`);
  await checkFileDir(config.tsFile);
  await fs.writeFile(config.tsFile, out.join('\n'));

  console.log(`write models file: ${config.modelsFile}`);
  await checkFileDir(config.modelsFile);
  await fs.writeFile(config.modelsFile, modelJs.join('\n'));
}

if (process.argv[2] !== 'gen' || !process.argv[3]) {
  console.log('zenorm gen config.json');
  process.exit(1);
} else {
  await main();
  process.exit();
}
